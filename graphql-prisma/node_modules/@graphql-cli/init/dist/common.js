"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.managePackageManifest = exports.BackendType = exports.FrontendType = exports.ProjectType = exports.InitializationType = exports.askForEnum = void 0;
const tslib_1 = require("tslib");
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const inquirer_1 = require("inquirer");
const fullname_1 = tslib_1.__importDefault(require("fullname"));
const latest_version_1 = tslib_1.__importDefault(require("latest-version"));
async function askForEnum(options) {
    let choices;
    const enumValues = Object.values(options.enum);
    if (options.ignoreList) {
        choices = enumValues.filter((enumValue) => !options.ignoreList.includes(enumValue));
    }
    else {
        choices = enumValues;
    }
    const { answer } = await inquirer_1.prompt([
        {
            type: 'list',
            name: 'answer',
            message: options.message,
            choices,
            default: options.defaultValue,
        },
    ]);
    return answer;
}
exports.askForEnum = askForEnum;
var InitializationType;
(function (InitializationType) {
    InitializationType["FromScratch"] = "I want to create a new project from a GraphQL CLI Project Template.";
    InitializationType["ExistingOpenAPI"] = "I have an existing project using OpenAPI/Swagger Schema Definition.";
    InitializationType["ExistingGraphQL"] = "I have an existing project using GraphQL and want to add GraphQL CLI (run from project root).";
})(InitializationType = exports.InitializationType || (exports.InitializationType = {}));
var ProjectType;
(function (ProjectType) {
    ProjectType["FullStack"] = "Full Stack";
    ProjectType["FrontendOnly"] = "Frontend only";
    ProjectType["BackendOnly"] = "Backend only";
})(ProjectType = exports.ProjectType || (exports.ProjectType = {}));
var FrontendType;
(function (FrontendType) {
    FrontendType["TSReactApollo"] = "TypeScript React Apollo";
    FrontendType["ApolloAngular"] = "Apollo Angular";
    FrontendType["StencilApollo"] = "Stencil Apollo";
    FrontendType["TSUrql"] = "TypeScript Urql";
    FrontendType["GraphQLRequest"] = "GraphQL Request";
    FrontendType["ApolloAndroid"] = "Apollo Android";
    FrontendType["Other"] = "Other";
})(FrontendType = exports.FrontendType || (exports.FrontendType = {}));
var BackendType;
(function (BackendType) {
    BackendType["TS"] = "TypeScript";
    BackendType["Java"] = "Java";
    BackendType["Kotlin"] = "Kotlin";
    BackendType["Other"] = "Other";
})(BackendType = exports.BackendType || (exports.BackendType = {}));
function managePackageManifest() {
    const packages = new Set();
    const scripts = new Map();
    return {
        addDependency(name) {
            packages.add(name);
        },
        addScript(name, script) {
            scripts.set(name, script);
        },
        async writePackage({ path, name, initializationType, }) {
            let packageJson = {};
            const packageJsonPath = path_1.join(path, 'package.json');
            // Try to load existing package.json
            try {
                const importedPackageJson = require(packageJsonPath);
                packageJson = importedPackageJson || {};
            }
            catch (err) { }
            if (initializationType === InitializationType.FromScratch) {
                packageJson.private = true;
                packageJson.name = name;
                const author = await fullname_1.default();
                if (author) {
                    packageJson.author = {
                        name: author,
                    };
                }
            }
            for (const [scriptName, scriptValue] of scripts) {
                if (!packageJson.scripts) {
                    packageJson.scripts = {};
                }
                if (!packageJson.scripts[scriptName]) {
                    packageJson.scripts[scriptName] = scriptValue;
                }
            }
            // Add dev dependencies
            packageJson.devDependencies = packageJson.devDependencies || {};
            for await (const npmDependency of packages) {
                if (!(npmDependency in packageJson.devDependencies)) {
                    packageJson.devDependencies[npmDependency] = await latest_version_1.default(npmDependency);
                }
            }
            await fs_extra_1.ensureFile(packageJsonPath);
            fs_extra_1.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
        },
    };
}
exports.managePackageManifest = managePackageManifest;
//# sourceMappingURL=common.js.map