import { Repeater } from '@repeaterjs/repeater';
export { Repeater } from '@repeaterjs/repeater';

const resolveGlobalConfig = (api = globalThis) => {
    if (!api.Event || !api.EventTarget) {
        throw new Error(`
[@graphql-yoga/subscription] 'createPubSub' uses the Event and EventTarget APIs.

In modern JavaScript environments those are part of the global scope. However, if you are using an older version of Node.js (< 16.x.x), those APIs must be polyfilled.
You can provide polyfills to the 'createPubSub' function:

\`\`\`
// yarn install --exact event-target-polyfill@0.0.3
import 'event-target-polyfill'

const pubSub = createPubSub()
\`\`\`

Alternatively, you can provide your own custom implementation.

\`\`\`
const pubSub = createPubSub({
  event: {
    Event,
    EventTarget,
  }
})
\`\`\`
`);
    }
    return globalThis;
};
/**
 * Utility for publishing and subscribing to events.
 */
const createPubSub = (config) => {
    var _a;
    const { Event, EventTarget } = resolveGlobalConfig(config === null || config === void 0 ? void 0 : config.event);
    const target = (_a = config === null || config === void 0 ? void 0 : config.eventTarget) !== null && _a !== void 0 ? _a : new EventTarget();
    return {
        publish(routingKey, ...args) {
            var _a;
            const payload = (_a = args[1]) !== null && _a !== void 0 ? _a : args[0];
            const topic = args[1] === undefined
                ? routingKey
                : `${routingKey}:${args[0]}`;
            const event = new Event(topic);
            event.data = payload;
            target.dispatchEvent(event);
        },
        subscribe(...[routingKey, id]) {
            const topic = id === undefined ? routingKey : `${routingKey}:${id}`;
            return new Repeater(function subscriptionRepeater(next, stop) {
                stop.then(function subscriptionRepeaterStopHandler() {
                    target.removeEventListener(topic, pubsubEventListener);
                });
                target.addEventListener(topic, pubsubEventListener);
                function pubsubEventListener(event) {
                    next(event.data);
                }
            });
        },
    };
};

/**
 * Utility for mapping an event stream.
 */
const map = (mapper) => (source) => new Repeater(async (push, stop) => {
    const iterable = source[Symbol.asyncIterator]();
    stop.then(() => {
        var _a;
        (_a = iterable.return) === null || _a === void 0 ? void 0 : _a.call(iterable);
    });
    let latest;
    while ((latest = await iterable.next()).done === false) {
        await push(await mapper(latest.value));
    }
    stop();
});

function filter(filter) {
    return (source) => new Repeater(async (push, stop) => {
        const iterable = source[Symbol.asyncIterator]();
        stop.then(() => {
            var _a;
            (_a = iterable.return) === null || _a === void 0 ? void 0 : _a.call(iterable);
        });
        let latest;
        while ((latest = await iterable.next()).done === false) {
            if (filter(latest.value)) {
                await push(latest.value);
            }
        }
        stop();
    });
}

function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
    switch (arguments.length) {
        case 1:
            return a;
        case 2:
            return ab(a);
        case 3:
            return bc(ab(a));
        case 4:
            return cd(bc(ab(a)));
        case 5:
            return de(cd(bc(ab(a))));
        case 6:
            return ef(de(cd(bc(ab(a)))));
        case 7:
            return fg(ef(de(cd(bc(ab(a))))));
        case 8:
            return gh(fg(ef(de(cd(bc(ab(a)))))));
        case 9:
            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
        default:
            let ret = arguments[0];
            for (let i = 1; i < arguments.length; i++) {
                ret = arguments[i](ret);
            }
            return ret;
    }
}

export { createPubSub, filter, map, pipe };
