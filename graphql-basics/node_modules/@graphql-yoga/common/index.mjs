import { envelop, enableIf, useSchema, useLogger, useExtendContext, useMaskedErrors } from '@envelop/core';
export * from '@envelop/core';
export { EnvelopError as GraphQLYogaError } from '@envelop/core';
import { inspect, isAsyncIterable } from '@graphql-tools/utils';
import { GraphQLError, getOperationAST, isSchema, print } from 'graphql';
import { useValidationCache } from '@envelop/validation-cache';
import { useParserCache } from '@envelop/parser-cache';
import { makeExecutableSchema } from '@graphql-tools/schema';
import { Request, Response, fetch, ReadableStream } from 'cross-undici-fetch';
import { dset } from 'dset';
export * from '@graphql-yoga/subscription';

const ANSI_CODES = {
    black: '\x1b[30m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m',
    white: '\x1b[37m',
    reset: '\x1b[0m',
    bold: '\x1b[1m',
    orange: '\x1b[48:5:166m',
};
const warnColor = (msg) => ANSI_CODES.orange + msg + ANSI_CODES.reset;
const infoColor = (msg) => ANSI_CODES.cyan + msg + ANSI_CODES.reset;
const errorColor = (msg) => ANSI_CODES.red + msg + ANSI_CODES.reset;
const debugColor = (msg) => ANSI_CODES.magenta + msg + ANSI_CODES.reset;
const titleBold = (msg) => ANSI_CODES.bold + msg + ANSI_CODES.reset;
const isDebug = () => (typeof process === 'object' ? process.env.DEBUG : false);
function getPrefix() {
    return titleBold(`üßò Yoga -`);
}
function getLoggerMessage(...args) {
    return args
        .map((arg) => (typeof arg === 'string' ? arg : inspect(arg)))
        .join(` `);
}
const defaultYogaLogger = {
    debug(...args) {
        if (isDebug()) {
            const message = getLoggerMessage(...args);
            const fullMessage = `${getPrefix()} üêõ ${debugColor(message)}`;
            // Some environments don't have other console methods
            if (console.debug) {
                console.debug(fullMessage);
            }
            else {
                console.log(fullMessage);
            }
        }
    },
    info(...args) {
        const message = getLoggerMessage(...args);
        const fullMessage = `${getPrefix()} üí° ${infoColor(message)}`;
        if (console.info) {
            console.info(fullMessage);
        }
        else {
            console.log(fullMessage);
        }
    },
    warn(...args) {
        const message = getLoggerMessage(...args);
        const fullMessage = `${getPrefix()} ‚ö†Ô∏è ${warnColor(message)}`;
        if (console.warn) {
            console.warn(fullMessage);
        }
        else {
            console.log(fullMessage);
        }
    },
    error(...args) {
        const message = getLoggerMessage(...args);
        const fullMessage = `${getPrefix()} ‚ùå ${errorColor(message)}`;
        if (console.error) {
            console.error(fullMessage);
        }
        else {
            console.log(fullMessage);
        }
    },
};

const graphiqlHTML = "<!doctype html><html lang=en><meta charset=utf-8><title>__TITLE__</title><link href=https://www.graphql-yoga.com/favicon.ico rel=icon><link href=https://unpkg.com/@graphql-yoga/graphiql/dist/style.css rel=stylesheet><body class=no-focus-outline id=body><noscript>You need to enable JavaScript to run this app.</noscript><div id=root></div><script type=module>import{renderYogaGraphiQL as r}from\"https://unpkg.com/@graphql-yoga/graphiql\";r(root,__OPTS__);</script>";

function shouldRenderGraphiQL({ headers, method }) {
    var _a;
    return method === 'GET' && !!((_a = headers === null || headers === void 0 ? void 0 : headers.get('accept')) === null || _a === void 0 ? void 0 : _a.includes('text/html'));
}
const renderGraphiQL = (opts) => graphiqlHTML
    .replace('__TITLE__', (opts === null || opts === void 0 ? void 0 : opts.title) || 'Yoga GraphiQL')
    .replace('__OPTS__', JSON.stringify(opts !== null && opts !== void 0 ? opts : {}));

const GETRequestParser = {
    is: (request) => request.method === 'GET',
    parse: async (request) => {
        const [, searchParamsStr] = request.url.split('?');
        const searchParams = new URLSearchParams(searchParamsStr);
        const operationName = searchParams.get('operationName') || undefined;
        const query = searchParams.get('query') || undefined;
        const variables = searchParams.get('variables') || undefined;
        const extensions = searchParams.get('extensions') || undefined;
        return {
            operationName,
            query,
            variables: variables ? JSON.parse(variables) : undefined,
            extensions: extensions ? JSON.parse(extensions) : undefined,
        };
    },
};
const POSTRequestParser = {
    is: (request) => request.method === 'POST',
    parse: async (request) => {
        const requestBody = await request.json();
        return {
            operationName: requestBody.operationName,
            query: requestBody.query,
            variables: requestBody.variables,
            extensions: requestBody.extensions,
        };
    },
};
const POSTMultipartFormDataRequestParser = {
    is: (request) => {
        var _a;
        return request.method === 'POST' &&
            !!((_a = request.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.startsWith('multipart/form-data'));
    },
    parse: async (request) => {
        var _a, _b;
        const requestBody = await request.formData();
        const operationsStr = ((_a = requestBody.get('operations')) === null || _a === void 0 ? void 0 : _a.toString()) || '{}';
        const operations = JSON.parse(operationsStr);
        const mapStr = ((_b = requestBody.get('map')) === null || _b === void 0 ? void 0 : _b.toString()) || '{}';
        const map = JSON.parse(mapStr);
        for (const fileIndex in map) {
            const file = requestBody.get(fileIndex);
            const [path] = map[fileIndex];
            dset(operations, path, file);
        }
        return {
            operationName: operations.operationName,
            query: operations.query,
            variables: operations.variables,
            extensions: operations.extensions,
        };
    },
};
function buildGetGraphQLParameters(parsers) {
    return async function getGraphQLParameters(request) {
        for (const parser of parsers) {
            if (parser.is(request)) {
                return parser.parse(request);
            }
        }
        return {
            operationName: undefined,
            query: undefined,
            variables: undefined,
            extensions: undefined,
        };
    };
}
const getGraphQLParameters = buildGetGraphQLParameters([
    GETRequestParser,
    POSTMultipartFormDataRequestParser,
    POSTRequestParser,
]);

let encodeString;
if (globalThis.Buffer) {
    encodeString = function encodeStringWithBuffer(str) {
        return globalThis.Buffer.from(str, 'utf8');
    };
}
else {
    const textEncoder = new TextEncoder();
    encodeString = function encodeStringWithTextEncoder(str) {
        return textEncoder.encode(str);
    };
}

async function* getSingleResult(payload) {
    yield payload;
}
function getExecutableOperation(document, operationName) {
    const operation = getOperationAST(document, operationName);
    if (!operation) {
        throw new Error('Could not determine what operation to execute.');
    }
    return operation;
}
async function processRequest({ contextFactory, execute, operationName, parse, query, request, schema, subscribe, validate, variables, extraHeaders, Response, ReadableStream, }) {
    var _a;
    function getErrorResponse({ status = 500, headers, errors, isEventStream, }) {
        const payload = {
            data: null,
            errors,
        };
        if (isEventStream) {
            return getPushResponse(getSingleResult(payload));
        }
        const decodedString = encodeString(JSON.stringify(payload));
        return new Response(decodedString, {
            status,
            headers: {
                ...headers,
                'Content-Type': 'application/json',
                'Content-Length': decodedString.byteLength.toString(),
            },
        });
    }
    function getRegularResponse(executionResult) {
        const responseBody = JSON.stringify(executionResult);
        const decodedString = encodeString(responseBody);
        const headersInit = {
            ...extraHeaders,
            'Content-Type': 'application/json',
            'Content-Length': decodedString.byteLength.toString(),
        };
        const responseInit = {
            headers: headersInit,
            status: 200,
        };
        return new Response(decodedString, responseInit);
    }
    function getMultipartResponse(asyncExecutionResult) {
        const headersInit = {
            ...extraHeaders,
            Connection: 'keep-alive',
            'Content-Type': 'multipart/mixed; boundary="-"',
            'Transfer-Encoding': 'chunked',
        };
        const responseInit = {
            headers: headersInit,
            status: 200,
        };
        let iterator;
        const readableStream = new ReadableStream({
            start(controller) {
                iterator = asyncExecutionResult[Symbol.asyncIterator]();
                controller.enqueue(encodeString(`---`));
            },
            async pull(controller) {
                const { done, value } = await iterator.next();
                if (value != null) {
                    controller.enqueue(encodeString('\r\n'));
                    controller.enqueue(encodeString('Content-Type: application/json; charset=utf-8'));
                    controller.enqueue(encodeString('\r\n'));
                    const chunk = JSON.stringify(value);
                    const encodedChunk = encodeString(chunk);
                    controller.enqueue(encodeString('Content-Length: ' + encodedChunk.byteLength));
                    controller.enqueue(encodeString('\r\n'));
                    controller.enqueue(encodeString('\r\n'));
                    controller.enqueue(encodedChunk);
                    controller.enqueue(encodeString('\r\n'));
                    controller.enqueue(encodeString('---'));
                }
                if (done) {
                    controller.enqueue(encodeString('\r\n-----\r\n'));
                    controller.close();
                }
            },
            async cancel(e) {
                var _a;
                await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator, e));
            },
        });
        return new Response(readableStream, responseInit);
    }
    function getPushResponse(asyncExecutionResult) {
        const headersInit = {
            ...extraHeaders,
            'Content-Type': 'text/event-stream',
            Connection: 'keep-alive',
            'Cache-Control': 'no-cache',
            'Content-Encoding': 'none',
        };
        const responseInit = {
            headers: headersInit,
            status: 200,
        };
        let iterator;
        const readableStream = new ReadableStream({
            start() {
                iterator = asyncExecutionResult[Symbol.asyncIterator]();
            },
            async pull(controller) {
                const { done, value } = await iterator.next();
                if (value != null) {
                    const chunk = JSON.stringify(value);
                    controller.enqueue(encodeString(`data: ${chunk}\n\n`));
                }
                if (done) {
                    controller.close();
                }
            },
            async cancel(e) {
                var _a;
                await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator, e));
            },
        });
        return new Response(readableStream, responseInit);
    }
    let contextValue;
    let document;
    let operation;
    const isEventStream = !!((_a = request.headers
        .get('accept')) === null || _a === void 0 ? void 0 : _a.includes('text/event-stream'));
    try {
        if (request.method !== 'GET' && request.method !== 'POST') {
            return getErrorResponse({
                status: 405,
                headers: {
                    Allow: 'GET, POST',
                    ...extraHeaders,
                },
                errors: [
                    new GraphQLError('GraphQL only supports GET and POST requests.'),
                ],
                isEventStream,
            });
        }
        if (query == null) {
            return getErrorResponse({
                status: 400,
                errors: [new GraphQLError('Must provide query string.')],
                isEventStream,
                headers: extraHeaders,
            });
        }
        try {
            if (typeof query !== 'string' && query.kind === 'Document') {
                document = query;
            }
            else {
                document = parse(query);
            }
        }
        catch (e) {
            return getErrorResponse({
                status: 400,
                errors: [e],
                isEventStream,
                headers: extraHeaders,
            });
        }
        const validationErrors = validate(schema, document);
        if (validationErrors.length > 0) {
            return getErrorResponse({
                status: 400,
                errors: validationErrors,
                isEventStream,
                headers: extraHeaders,
            });
        }
        operation = getExecutableOperation(document, operationName);
        if (operation.operation === 'mutation' && request.method === 'GET') {
            return getErrorResponse({
                status: 405,
                errors: [
                    new GraphQLError('Can only perform a mutation operation from a POST request.'),
                ],
                headers: {
                    Allow: 'POST',
                    ...extraHeaders,
                },
                isEventStream,
            });
        }
        let variableValues;
        try {
            if (variables) {
                variableValues =
                    typeof variables === 'string' ? JSON.parse(variables) : variables;
            }
        }
        catch (_error) {
            return getErrorResponse({
                errors: [new GraphQLError('Variables are invalid JSON.')],
                status: 400,
                isEventStream,
                headers: extraHeaders,
            });
        }
        contextValue = await contextFactory();
        const executionArgs = {
            schema,
            document,
            contextValue,
            variableValues,
            operationName,
        };
        if (operation.operation === 'subscription') {
            const result = await subscribe(executionArgs);
            // If errors are encountered while subscribing to the operation, an execution result
            // instead of an AsyncIterable.
            if (isAsyncIterable(result)) {
                return getPushResponse(result);
            }
            else {
                if (isEventStream) {
                    return getPushResponse(result);
                }
                else {
                    return getRegularResponse(result);
                }
            }
        }
        else {
            const result = await execute(executionArgs);
            // Operations that use @defer, @stream and @live will return an `AsyncIterable` instead of an
            // execution result.
            if (isAsyncIterable(result)) {
                return isEventStream
                    ? getPushResponse(result)
                    : getMultipartResponse(result);
            }
            else {
                return getRegularResponse(result);
            }
        }
    }
    catch (error) {
        const errors = [
            error instanceof GraphQLError
                ? error
                : new GraphQLError(error.message, undefined, undefined, undefined, undefined, error),
        ];
        return getErrorResponse({
            status: 500,
            errors,
            isEventStream,
            headers: extraHeaders,
        });
    }
}

function getDefaultSchema() {
    return makeExecutableSchema({
        typeDefs: /* GraphQL */ `
      """
      Greetings from GraphQL Yoga!
      """
      type Query {
        greetings: String
      }
      type Subscription {
        """
        Current Time
        """
        time: String
      }
    `,
        resolvers: {
            Query: {
                greetings: () => 'This is the `greetings` field of the root `Query` type',
            },
            Subscription: {
                time: {
                    subscribe: async function* () {
                        while (true) {
                            yield { time: new Date().toISOString() };
                            await new Promise((resolve) => setTimeout(resolve, 1000));
                        }
                    },
                },
            },
        },
    });
}
/**
 * Base class that can be extended to create a GraphQL server with any HTTP server framework.
 * @internal
 */
class YogaServer {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.corsOptionsFactory = () => ({});
        this.id = Date.now().toString();
        this.handleRequest = async (request, ...args) => {
            const serverContext = args[0];
            try {
                if (request.method === 'OPTIONS') {
                    return this.handleOptions(request, ...args);
                }
                const requestPath = request.url.split('?')[0];
                if (requestPath.endsWith('/health')) {
                    return new this.fetchAPI.Response(`{ "message": "alive" }`, {
                        status: 200,
                        headers: {
                            'Content-Type': 'application/json',
                            'x-yoga-id': this.id,
                        },
                    });
                }
                if (requestPath.endsWith('/readiness')) {
                    const readinessResponse = await this.fetchAPI.fetch(request.url.replace('/readiness', '/health'));
                    const { message } = await readinessResponse.json();
                    if (readinessResponse.status === 200 &&
                        readinessResponse.headers.get('x-yoga-id') === this.id &&
                        message === 'alive') {
                        return new this.fetchAPI.Response(`{ "message": "ready" }`, {
                            status: 200,
                            headers: {
                                'Content-Type': 'application/json',
                            },
                        });
                    }
                    throw new Error(`Readiness check failed with status ${readinessResponse.status}`);
                }
                this.logger.debug(`Checking if GraphiQL Request`);
                if (this.endpoint != null && !requestPath.endsWith(this.endpoint)) {
                    return new this.fetchAPI.Response(`Unable to ${request.method} ${requestPath}`, {
                        status: 404,
                        statusText: `Not Found`,
                    });
                }
                if (shouldRenderGraphiQL(request)) {
                    let graphiqlOptions = this.graphiqlOptionsFactory(request, ...args);
                    if (graphiqlOptions) {
                        const graphiQLBody = await this.renderGraphiQL({
                            endpoint: this.endpoint,
                            ...(graphiqlOptions === true ? {} : graphiqlOptions),
                        });
                        return new this.fetchAPI.Response(graphiQLBody, {
                            headers: {
                                'Content-Type': 'text/html',
                            },
                            status: 200,
                        });
                    }
                }
                this.logger.debug(`Extracting GraphQL Parameters`);
                const { query, variables, operationName, extensions } = await getGraphQLParameters(request);
                const initialContext = {
                    request,
                    query,
                    variables,
                    operationName,
                    extensions,
                    ...serverContext,
                };
                const { execute, validate, subscribe, parse, contextFactory, schema } = this.getEnveloped(initialContext);
                this.logger.debug(`Processing Request`);
                const corsHeaders = this.getCORSResponseHeaders(request, initialContext);
                const response = await processRequest({
                    request,
                    query,
                    variables,
                    operationName,
                    execute,
                    validate,
                    subscribe,
                    parse,
                    contextFactory,
                    schema,
                    extraHeaders: corsHeaders,
                    Response: this.fetchAPI.Response,
                    ReadableStream: this.fetchAPI.ReadableStream,
                });
                return response;
            }
            catch (err) {
                this.logger.error(err.message, err.stack, err);
                const response = new this.fetchAPI.Response(err.message, {
                    status: 500,
                    statusText: 'Internal Server Error',
                });
                return response;
            }
        };
        this.fetch = (input, init) => {
            let request;
            if (typeof input === 'string') {
                request = new this.fetchAPI.Request(input, init);
            }
            else {
                request = input;
            }
            return this.handleRequest(request, init);
        };
        // FetchEvent is not available in all envs
        this.fetchEventListener = (event) => event.respondWith(this.handleRequest(event.request, event));
        this.fetchAPI = {
            Request: (_b = (_a = options === null || options === void 0 ? void 0 : options.fetchAPI) === null || _a === void 0 ? void 0 : _a.Request) !== null && _b !== void 0 ? _b : Request,
            Response: (_d = (_c = options === null || options === void 0 ? void 0 : options.fetchAPI) === null || _c === void 0 ? void 0 : _c.Response) !== null && _d !== void 0 ? _d : Response,
            fetch: (_f = (_e = options === null || options === void 0 ? void 0 : options.fetchAPI) === null || _e === void 0 ? void 0 : _e.fetch) !== null && _f !== void 0 ? _f : fetch,
            ReadableStream: (_h = (_g = options === null || options === void 0 ? void 0 : options.fetchAPI) === null || _g === void 0 ? void 0 : _g.ReadableStream) !== null && _h !== void 0 ? _h : ReadableStream,
        };
        const schema = (options === null || options === void 0 ? void 0 : options.schema)
            ? isSchema(options.schema)
                ? options.schema
                : makeExecutableSchema({
                    typeDefs: options.schema.typeDefs,
                    resolvers: options.schema.resolvers,
                })
            : getDefaultSchema();
        const logger = (options === null || options === void 0 ? void 0 : options.logging) != null ? options.logging : true;
        this.logger =
            typeof logger === 'boolean'
                ? logger === true
                    ? defaultYogaLogger
                    : {
                        debug: () => { },
                        error: () => { },
                        warn: () => { },
                        info: () => { },
                    }
                : logger;
        const maskedErrors = (_j = options === null || options === void 0 ? void 0 : options.maskedErrors) !== null && _j !== void 0 ? _j : true;
        this.getEnveloped = envelop({
            plugins: [
                // Use the schema provided by the user
                enableIf(schema != null, useSchema(schema)),
                // Performance things
                enableIf((options === null || options === void 0 ? void 0 : options.parserCache) !== false, () => useParserCache(typeof (options === null || options === void 0 ? void 0 : options.parserCache) === 'object'
                    ? options === null || options === void 0 ? void 0 : options.parserCache
                    : undefined)),
                enableIf((options === null || options === void 0 ? void 0 : options.validationCache) !== false, () => useValidationCache({
                    cache: typeof (options === null || options === void 0 ? void 0 : options.validationCache) === 'object'
                        ? options === null || options === void 0 ? void 0 : options.validationCache
                        : undefined,
                })),
                // Log events - useful for debugging purposes
                enableIf(logger !== false, useLogger({
                    logFn: (eventName, events) => {
                        this.logger.debug(eventName);
                        switch (eventName) {
                            case 'execute-start':
                                const { query, variables, operationName, } = events.args.contextValue;
                                this.logger.debug(query, 'query');
                                this.logger.debug(operationName, 'headers');
                                this.logger.debug(variables, 'variables');
                                break;
                            case 'execute-end':
                                this.logger.debug(events.result, 'response');
                                break;
                        }
                    },
                })),
                enableIf((options === null || options === void 0 ? void 0 : options.context) != null, useExtendContext(async (initialContext) => {
                    if (options === null || options === void 0 ? void 0 : options.context) {
                        if (typeof options.context === 'function') {
                            return options.context(initialContext);
                        }
                        else {
                            return options.context;
                        }
                    }
                })),
                ...((_k = options === null || options === void 0 ? void 0 : options.plugins) !== null && _k !== void 0 ? _k : []),
                enableIf(!!maskedErrors, useMaskedErrors(typeof maskedErrors === 'object' ? maskedErrors : undefined)),
            ],
        });
        if ((options === null || options === void 0 ? void 0 : options.cors) != null) {
            if (typeof options.cors === 'function') {
                this.corsOptionsFactory = options.cors;
            }
            else if (typeof options.cors === 'object') {
                const corsOptions = {
                    ...options.cors,
                };
                this.corsOptionsFactory = () => corsOptions;
            }
        }
        if (typeof (options === null || options === void 0 ? void 0 : options.graphiql) === 'function') {
            this.graphiqlOptionsFactory = options.graphiql;
        }
        else if (typeof (options === null || options === void 0 ? void 0 : options.graphiql) === 'object') {
            this.graphiqlOptionsFactory = () => options.graphiql;
        }
        else if ((options === null || options === void 0 ? void 0 : options.graphiql) === false) {
            this.graphiqlOptionsFactory = () => false;
        }
        else {
            this.graphiqlOptionsFactory = () => ({});
        }
        this.renderGraphiQL = (options === null || options === void 0 ? void 0 : options.renderGraphiQL) || renderGraphiQL;
        this.endpoint = options === null || options === void 0 ? void 0 : options.endpoint;
    }
    getCORSResponseHeaders(request, ...args) {
        var _a, _b, _c;
        const corsOptions = this.corsOptionsFactory(request, ...args);
        const headers = {};
        const currentOrigin = request.headers.get('origin');
        headers['Access-Control-Allow-Origin'] = '*';
        if (currentOrigin) {
            const credentialsAsked = request.headers.get('cookies');
            if (credentialsAsked) {
                headers['Access-Control-Allow-Origin'] = currentOrigin;
            }
        }
        if (currentOrigin != null &&
            ((_a = corsOptions.origin) === null || _a === void 0 ? void 0 : _a.length) &&
            !corsOptions.origin.includes(currentOrigin) &&
            !corsOptions.origin.includes('*')) {
            headers['Access-Control-Allow-Origin'] = 'null';
        }
        if (headers['Access-Control-Allow-Origin'] !== '*') {
            headers['Vary'] = 'Origin';
        }
        if ((_b = corsOptions.methods) === null || _b === void 0 ? void 0 : _b.length) {
            headers['Access-Control-Allow-Methods'] = corsOptions.methods.join(', ');
        }
        else {
            const requestMethod = request.headers.get('access-control-request-method');
            if (requestMethod) {
                headers['Access-Control-Allow-Methods'] = requestMethod;
            }
        }
        if ((_c = corsOptions.allowedHeaders) === null || _c === void 0 ? void 0 : _c.length) {
            headers['Access-Control-Allow-Headers'] =
                corsOptions.allowedHeaders.join(', ');
        }
        else {
            const requestHeaders = request.headers.get('access-control-request-headers');
            if (requestHeaders) {
                headers['Access-Control-Allow-Headers'] = requestHeaders;
                if (headers['Vary']) {
                    headers['Vary'] += ', Access-Control-Request-Headers';
                }
                headers['Vary'] = 'Access-Control-Request-Headers';
            }
        }
        if (corsOptions.credentials != null) {
            if (corsOptions.credentials === true) {
                headers['Access-Control-Allow-Credentials'] = 'true';
            }
        }
        else if (headers['Access-Control-Allow-Origin'] !== '*') {
            headers['Access-Control-Allow-Credentials'] = 'true';
        }
        if (corsOptions.exposedHeaders) {
            headers['Access-Control-Expose-Headers'] =
                corsOptions.exposedHeaders.join(', ');
        }
        if (corsOptions.maxAge) {
            headers['Access-Control-Max-Age'] = corsOptions.maxAge.toString();
        }
        headers['Server'] = 'GraphQL Yoga';
        return headers;
    }
    handleOptions(request, ...args) {
        const headers = this.getCORSResponseHeaders(request, ...args);
        const optionsResponse = new this.fetchAPI.Response(null, {
            status: 204,
            headers,
        });
        return optionsResponse;
    }
    /**
     * Testing utility to mock http request for GraphQL endpoint
     *
     *
     * Example - Test a simple query
     * ```ts
     * const response = await yoga.inject({
     *  document: "query { ping }",
     * })
     * expect(response.statusCode).toBe(200)
     * expect(response.data.ping).toBe('pong')
     * ```
     **/
    async inject({ document, variables, operationName, headers, serverContext, }) {
        const request = new this.fetchAPI.Request('http://localhost/graphql', {
            method: 'POST',
            headers,
            body: JSON.stringify({
                query: document &&
                    (typeof document === 'string' ? document : print(document)),
                variables,
                operationName,
            }),
        });
        const response = await this.handleRequest(request, serverContext);
        let executionResult = null;
        if (response.headers.get('content-type') === 'application/json') {
            executionResult = await response.json();
        }
        return {
            response,
            executionResult,
        };
    }
    start() {
        self.addEventListener('fetch', this.fetchEventListener);
    }
    stop() {
        self.removeEventListener('fetch', this.fetchEventListener);
    }
}
function createServer(options) {
    const server = new YogaServer(options);
    // TODO: Will be removed once we get rid of classes
    const fnHandler = (input) => {
        if (input.request) {
            return server.handleRequest(input.request, input);
        }
        else {
            return server.handleRequest(input, undefined);
        }
    };
    return new Proxy(fnHandler, {
        get: (_, prop) => {
            if (server[prop]) {
                if (server[prop].bind) {
                    return server[prop].bind(server);
                }
                return server[prop];
            }
            else if (fnHandler[prop]) {
                if (fnHandler[prop].bind) {
                    return fnHandler[prop].bind(fnHandler);
                }
                return fnHandler[prop];
            }
        },
        apply(_, __, [input]) {
            return fnHandler(input);
        },
    });
}

export { YogaServer, createServer, defaultYogaLogger, getDefaultSchema, renderGraphiQL, shouldRenderGraphiQL };
