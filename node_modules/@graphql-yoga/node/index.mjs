import { createServer as createServer$2 } from 'http';
import { createServer as createServer$1 } from 'https';
import { Readable } from 'stream';
import { isAsyncIterable } from '@graphql-tools/utils';
import { YogaServer } from '@graphql-yoga/common';
export { GraphQLYogaError, renderGraphiQL, shouldRenderGraphiQL } from '@graphql-yoga/common';
import { platform, release } from 'os';
import { create } from 'cross-undici-fetch';
export * from '@envelop/core';
export * from '@graphql-yoga/subscription';

function getRequestAddressInfo(nodeRequest, defaultAddressInfo) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const hostname = nodeRequest.hostname ||
        ((_e = (_d = (_c = (_b = (_a = nodeRequest.socket) === null || _a === void 0 ? void 0 : _a.localAddress) === null || _b === void 0 ? void 0 : _b.split('ffff')) === null || _c === void 0 ? void 0 : _c.join('')) === null || _d === void 0 ? void 0 : _d.split(':')) === null || _e === void 0 ? void 0 : _e.join('')) ||
        ((_g = (_f = nodeRequest.headers) === null || _f === void 0 ? void 0 : _f.host) === null || _g === void 0 ? void 0 : _g.split(':')[0]) ||
        defaultAddressInfo.hostname ||
        'localhost';
    const port = ((_h = nodeRequest.socket) === null || _h === void 0 ? void 0 : _h.localPort) || defaultAddressInfo.port || 80;
    return {
        protocol: (nodeRequest.protocol ||
            defaultAddressInfo.protocol ||
            'http'),
        hostname,
        endpoint: nodeRequest.url || defaultAddressInfo.endpoint,
        port,
    };
}
function buildFullUrl(addressInfo) {
    return `${addressInfo.protocol}://${addressInfo.hostname}:${addressInfo.port}${addressInfo.endpoint}`;
}
function configureSocket(rawRequest) {
    var _a, _b, _c, _d, _e, _f;
    (_b = (_a = rawRequest === null || rawRequest === void 0 ? void 0 : rawRequest.socket) === null || _a === void 0 ? void 0 : _a.setTimeout) === null || _b === void 0 ? void 0 : _b.call(_a, 0);
    (_d = (_c = rawRequest === null || rawRequest === void 0 ? void 0 : rawRequest.socket) === null || _c === void 0 ? void 0 : _c.setNoDelay) === null || _d === void 0 ? void 0 : _d.call(_c, true);
    (_f = (_e = rawRequest === null || rawRequest === void 0 ? void 0 : rawRequest.socket) === null || _e === void 0 ? void 0 : _e.setKeepAlive) === null || _f === void 0 ? void 0 : _f.call(_e, true);
}
function getNodeRequest(nodeRequest, defaultAddressInfo, RequestCtor) {
    var _a;
    const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;
    configureSocket(rawRequest);
    const addressInfo = getRequestAddressInfo(rawRequest, defaultAddressInfo);
    let fullUrl = buildFullUrl(addressInfo);
    if (nodeRequest.query) {
        const urlObj = new URL(fullUrl);
        for (const queryName in nodeRequest.query) {
            const queryValue = nodeRequest.query[queryName];
            urlObj.searchParams.set(queryName, queryValue);
        }
    }
    const baseRequestInit = {
        method: nodeRequest.method,
        headers: nodeRequest.headers,
    };
    if (nodeRequest.method !== 'POST') {
        return new RequestCtor(fullUrl, baseRequestInit);
    }
    /**
     * Some Node server frameworks like Serverless Express sends a dummy object with body but as a Buffer not string
     * so we do those checks to see is there something we can use directly as BodyInit
     * because the presence of body means the request stream is already consumed and,
     * rawRequest cannot be used as BodyInit/ReadableStream by Fetch API in this case.
     */
    const maybeParsedBody = nodeRequest.body;
    if (maybeParsedBody != null) {
        if (typeof maybeParsedBody === 'string' ||
            maybeParsedBody[Symbol.toStringTag] === 'Uint8Array' ||
            maybeParsedBody[Symbol.toStringTag] === 'Blob' ||
            maybeParsedBody[Symbol.toStringTag] === 'FormData' ||
            maybeParsedBody[Symbol.toStringTag] === 'URLSearchParams' ||
            isAsyncIterable(maybeParsedBody)) {
            return new RequestCtor(fullUrl, {
                ...baseRequestInit,
                body: maybeParsedBody,
            });
        }
        const request = new RequestCtor(fullUrl, {
            ...baseRequestInit,
        });
        if (!((_a = request.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('json'))) {
            request.headers.set('content-type', 'application/json');
        }
        return new Proxy(request, {
            get: (target, prop, receiver) => {
                switch (prop) {
                    case 'json':
                        return async () => maybeParsedBody;
                    default:
                        return Reflect.get(target, prop, receiver);
                }
            },
        });
    }
    return new RequestCtor(fullUrl, {
        headers: nodeRequest.headers,
        method: nodeRequest.method,
        body: rawRequest,
    });
}
function isReadable(responseBody) {
    return !!responseBody.pipe;
}
function sendNodeResponse({ headers, status, statusText, body }, serverResponse) {
    headers.forEach((value, name) => {
        serverResponse.setHeader(name, value);
    });
    serverResponse.statusCode = status;
    serverResponse.statusMessage = statusText;
    if (body == null) {
        serverResponse.end();
        return Promise.resolve();
    }
    else {
        if (body[Symbol.toStringTag] === 'Uint8Array') {
            serverResponse.end(body);
            return Promise.resolve();
        }
        const nodeStream = isReadable(body) ? body : Readable.from(body);
        const promise = new Promise((resolve) => nodeStream.once('end', resolve));
        nodeStream.pipe(serverResponse);
        return promise;
    }
}

class YogaNodeServer extends YogaServer {
    constructor(options) {
        var _a, _b;
        super({
            ...options,
            fetchAPI: (_a = options === null || options === void 0 ? void 0 : options.fetchAPI) !== null && _a !== void 0 ? _a : create({
                useNodeFetch: true,
            }),
        });
        this.options = options;
        this.nodeServer = null;
        this.requestListener = async (req, res) => {
            const response = await this.handleIncomingMessage(req, { req, res });
            this.logger.debug('Sending response to Node Server');
            return sendNodeResponse(response, res);
        };
        this.handle = this.requestListener;
        this.addressInfo = {
            // Windows doesn't support 0.0.0.0 binding
            // We need to use 127.0.0.1 for Windows and WSL
            hostname: (options === null || options === void 0 ? void 0 : options.hostname) ||
                // Is Windows?
                (platform() === 'win32' ||
                    // is WSL?
                    release().toLowerCase().includes('microsoft')
                    ? '127.0.0.1'
                    : '0.0.0.0'),
            port: (_b = options === null || options === void 0 ? void 0 : options.port) !== null && _b !== void 0 ? _b : parseInt(process.env.PORT || '4000'),
            endpoint: (options === null || options === void 0 ? void 0 : options.endpoint) || '/graphql',
            protocol: (options === null || options === void 0 ? void 0 : options.https) ? 'https' : 'http',
        };
        this.logger.debug('Setting up server.');
    }
    getNodeServer() {
        var _a, _b;
        if (!this.nodeServer) {
            this.endpoint = this.endpoint || '/graphql';
            if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.https) {
                this.nodeServer =
                    typeof ((_b = this.options) === null || _b === void 0 ? void 0 : _b.https) === 'object'
                        ? createServer$1(this.options.https, this.requestListener)
                        : createServer$1(this.requestListener);
            }
            else {
                this.nodeServer = createServer$2(this.requestListener);
            }
        }
        return this.nodeServer;
    }
    getAddressInfo() {
        return this.addressInfo;
    }
    getServerUrl() {
        return `${this.addressInfo.protocol}://${this.addressInfo.hostname}:${this.addressInfo.port}${this.addressInfo.endpoint}`;
    }
    async handleIncomingMessage(nodeRequest, serverContext) {
        this.logger.debug(`Node Request received`);
        const request = getNodeRequest(nodeRequest, this.addressInfo, this.fetchAPI.Request);
        this.logger.debug('Node Request processed');
        const response = await this.handleRequest(request, serverContext);
        return response;
    }
    start() {
        const nodeServer = this.getNodeServer();
        return new Promise((resolve, reject) => {
            try {
                nodeServer.listen(this.addressInfo.port, this.addressInfo.hostname, () => {
                    const serverUrl = this.getServerUrl();
                    this.logger.info(`GraphQL Server running at ${serverUrl}`);
                    resolve();
                });
            }
            catch (e) {
                this.logger.error(`GraphQL Server couldn't start`, e);
                reject(e);
            }
        });
    }
    stop() {
        const nodeServer = this.getNodeServer();
        this.logger.info('Shutting down GraphQL Server');
        return new Promise((resolve, reject) => {
            nodeServer.close((err) => {
                if (err != null) {
                    this.logger.error('Something went wrong while trying to shutdown the server', err);
                    reject(err);
                }
                else {
                    this.logger.info(`GraphQL Server stopped successfully`);
                    resolve();
                }
            });
        });
    }
}
/**
 * Create a simple yet powerful GraphQL server ready for production workloads.
 * Spec compliant server that supports bleeding edge GraphQL features without any vendor lock-ins.
 *
 * Comes baked in with:
 *
 * - Envelop - Plugin system for GraphQL
 * - GraphiQL - GraphQL IDE for your browser
 *
 * Example:
 * ```ts
 *  import { schema } from './schema'
 *   // Provide a GraphQL schema
 *  const server = createServer({ schema })
 *  // Start the server. Defaults to http://localhost:4000/graphql
 *  server.start()
 * ```
 */
function createServer(options) {
    const server = new YogaNodeServer(options);
    return new Proxy(server.requestListener, {
        get: (_, prop) => {
            if (server[prop]) {
                if (server[prop].bind) {
                    return server[prop].bind(server);
                }
                return server[prop];
            }
            else if (server.requestListener[prop]) {
                if (server.requestListener[prop].bind) {
                    return server.requestListener[prop].bind(server.requestListener);
                }
                return server.requestListener[prop];
            }
        },
        apply: (_, __, [req, res]) => server.requestListener(req, res),
    });
}

export { createServer };
